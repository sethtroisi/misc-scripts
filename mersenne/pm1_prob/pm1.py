

# This file was *autogenerated* from the file pm1.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_150 = Integer(150); _sage_const_200 = Integer(200); _sage_const_0p5 = RealNumber('0.5'); _sage_const_1p45 = RealNumber('1.45'); _sage_const_0p02 = RealNumber('0.02'); _sage_const_86400 = Integer(86400); _sage_const_70 = Integer(70); _sage_const_1000000 = Integer(1000000); _sage_const_150000 = Integer(150000); _sage_const_20 = Integer(20); _sage_const_0p666 = RealNumber('0.666'); _sage_const_100 = Integer(100); _sage_const_1en2 = RealNumber('1e-2'); _sage_const_1p977 = RealNumber('1.977')# Adaption of GpuOwl's pm1.cpp
# https://github.com/preda/gpuowl/blob/master/pm1/pm1.cpp
# Copyright: GPL v3

# Adjustments
# 1. Use Sage dickman_rho() instead of precomputed table
# 2. Eval integral at more points
#

# Preda's code makes use of a table and linear interpolation to compute rho
# in sage we have direct access to dickman_rho

from fft import fft_timing_data, fft_size_data


def prob_stage1(alpha):
    '''
    Probability of finding factor in first stage

    This is the probability that the largest factor is < alpha
    '''
    return dickman_rho(alpha)


def prob_stage2(alpha, beta):
    '''
    Probability of finding factor in 1st (alpha) or 2nd stage (beta)

    See "Some Integer Factorization Algorithms using Elliptic Curves", R. P. Brent, page 3.
    https://maths-people.anu.edu.au/~brent/pd/rpb102.pdf
    Also "Speeding up Integer Multiplication and Factorization", A. Kruppa, chapter 5.3.3 (page 102).
    '''

    # alpha = M_bits / log(B1)
    # beta  = M_bits / log(B2)
    # B1 > B2   =>  alpha > beta
    assert alpha >= beta

    # See https://www.mersenneforum.org/showthread.php?p=553516
    def f(x):
        return dickman_rho(alpha - x) / x

    # Ratio of B2 / B1
    return numerical_integral(f, _sage_const_1 , alpha / beta)[_sage_const_0 ]


def prob_pm1(exponent, cleared, B1, B2):
    '''Probability of factor > cleared (e.g. 2^70, 10^20) for M<exp> = 2^exponent-1'''

    # Mersenne factors have a special form 2*k*p+1 for M<p>
    # so a factor of size F is actually a factor of size F/(2*p)

    sum_prob_s1 = _sage_const_0 
    sum_prob = _sage_const_0 

    factor_start = log(cleared)
    factor_end = log(_sage_const_2  ** _sage_const_150 )
    slices = _sage_const_200 
    log_per_slice = ((factor_end - factor_start) / slices).n()

    # Integrate over size of found factor F in 300 slices
    for i in range(slices):
        # Interval is [sta, end] with mid (logarithmically) of mid
        sta = exp(factor_start + i * log_per_slice).n()
        mid = exp(factor_start + (i + _sage_const_0p5 ) * log_per_slice).n()
        end = exp(factor_start + (i + _sage_const_1 ) * log_per_slice).n()

        # Probability of finding a factor in this interval
        # See: Merten's 2nd Theorem
        prob_factor = log(log(end)) - log(log(sta))
        # 1/alpha, 1/beta for dickman_rho
        alpha = (log(mid/_sage_const_2 /exponent) / log(B1)).n()
        beta  = (log(mid/_sage_const_2 /exponent) / log(B2)).n()
        p1 = prob_stage1(alpha)       * prob_factor
        p2 = prob_stage2(alpha, beta) * prob_factor

        sum_prob_s1 += p1 * (_sage_const_1  - sum_prob_s1)
        sum_prob    += (p1 + p2) * (_sage_const_1  - sum_prob)

    return float(sum_prob_s1), float(sum_prob)


def n_primes_between(B1, B2):
    # Sage has a very fast PrimePi
    if B2 <= B1:
        return _sage_const_0 
    return prime_pi(B2) - prime_pi(B1)


def get_FFT_size(exponent):
    '''Find appropriate length for FFT'''
    for max_exp, size in fft_size_data:
        if max_exp > exponent:
            return size
    assert False, exponent

def get_FFT_timing(exponent):
    '''Find FFT timing

    Uses a minimized version of James data
    See: https://www.mersenneforum.org/showpost.php?p=593701&postcount=707
    '''
    fftlen = get_FFT_size(exponent)
    best = fft_timing_data[_sage_const_0 ][_sage_const_1 ]
    for size, timing in fft_timing_data:
        if size >= fftlen:
            best = timing
        else:
            break
    return best


def credit(exponent, B1, B2):
    '''GIMPS CPU Credit (GHz-Days) for a P-1 assignment

    See: https://mersenneforum.org/showpost.php?p=152280&postcount=204
    and https://www.mersenneforum.org/showthread.php?t=10937
    '''
    timing = get_FFT_timing(exponent)

    # TODO update after 30.8 is finalized
    credit = _sage_const_1p45  * B1 + _sage_const_0p02  * (B2 - B1)
    return float(timing * credit / _sage_const_86400 )


def test():
    # TODO add more test cases
    clear = _sage_const_2  ** _sage_const_70 
    M  = _sage_const_1000000 
    B1 = _sage_const_150000 
    B2 = _sage_const_20  * B1
    prob = prob_pm1(M, clear, B1, B2)
    #print(f"prob({M:,}, B1={B1:,}, B2={B2:,}, {clear:.1e}) = {prob[0]:.3%} {prob[1]:.3%}")
    assert abs(prob[_sage_const_0 ] - _sage_const_0p666 /_sage_const_100 ) < _sage_const_1en2 
    assert abs(prob[_sage_const_1 ] - _sage_const_1p977 /_sage_const_100 ) < _sage_const_1en2 

    #w = credit(M, B1, B2)
    #assert abs(w - 0.01312) < 1e-4

test()


